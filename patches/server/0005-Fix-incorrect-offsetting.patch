From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <novau233@163.com>
Date: Wed, 3 Jan 2024 13:51:30 +0000
Subject: [PATCH] Fix incorrect offsetting


diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index ba768596ec42baa008dc0136ea1cbabb53d46528..34bdff0bb7dd8f6f7da61369011952ed8a186314 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -177,7 +177,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             }
             final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> got = ((ServerLevel) chunk.level).regioniser.getRegionAtUnsynchronised(chunk.getPos().getMiddleBlockX(),chunk.getPos().getMiddleBlockZ());
             if (got != null) {
-                got.getData().getRegionStats().updateFrom(Level.WORLD_DATA_POOL.getDataAnyThread(chunk.level,chunk.getPos().getMiddleBlockX(),chunk.getPos().getMiddleBlockZ()));
+                got.getData().getRegionStats().updateFrom(Level.WORLD_DATA_POOL.getDataAnyThread(chunk.getPos().x,chunk.getPos().z,chunk.level));
             }else{
                 Bukkit.getRegionScheduler().execute(MINECRAFT,chunk.level.getWorld(),chunk.getPos().x,chunk.getPos().z,()->{
                     TickRegionScheduler.getCurrentRegion().getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
diff --git a/src/main/java/me/earthme/lightingluminol/pool/WorldDataPool.java b/src/main/java/me/earthme/lightingluminol/pool/WorldDataPool.java
index d7ef1ad984f63e2b5545a8df081015bbf7cc144f..3e7f358a1a8623be58ef4f842f37b09beeb926e1 100644
--- a/src/main/java/me/earthme/lightingluminol/pool/WorldDataPool.java
+++ b/src/main/java/me/earthme/lightingluminol/pool/WorldDataPool.java
@@ -32,6 +32,13 @@ public class WorldDataPool {
         return got == null ? getDataOffTickThread(x >> 4,z >> 4, ((ServerLevel) level)) : got; //Skip it if we got the current world data
     }
 
+    @Nullable
+    public RegionizedWorldData getDataAnyThread(int chunkX,int chunkZ,Level level){
+        final RegionizedWorldData got = level.getCurrentWorldDataUnsafe();
+        return got == null ? getDataOffTickThread(chunkX,chunkZ, ((ServerLevel) level)) : got; //Skip it if we got the current world data
+    }
+
+
     @Nullable
     public RegionizedWorldData getDataAnyThread(@NotNull Location loc){
         final RegionizedWorldData got = ((CraftWorld) loc.getWorld()).getHandle().getCurrentWorldDataUnsafe();
@@ -47,7 +54,6 @@ public class WorldDataPool {
             return ret;
         }
 
-        return null;
-        //return CompletableFuture.supplyAsync(level::getCurrentWorldData,SchedulerUtil.regionSchedulerAsExecutor(chunkX,chunkZ,level)).join();
+        return null; //TODO Fast-fail?
     }
 }
diff --git a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
index 7d5719e3429b68501a223a3e0825c655330c9376..92d61b242128cde0989a720adfb28ebd738a6c1f 100644
--- a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
+++ b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
@@ -1,7 +1,9 @@
 package net.minecraft.server.level;
 
+import ca.spottedleaf.starlight.common.light.StarLightInterface;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.RegionizedServer;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectList;
 import it.unimi.dsi.fastutil.objects.ObjectListIterator;
@@ -162,7 +164,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
         }
         updateFuture.isTicketAdded = true;
 
-        final int references = Level.WORLD_DATA_POOL.getDataAnyThread(this.chunkMap.level,chunkX << 4,chunkZ << 4).chunksBeingWorkedOn.addTo(key, 1); // Folia - region threading
+        final int references = Level.WORLD_DATA_POOL.getDataAnyThread(chunkX,chunkZ,this.chunkMap.level).chunksBeingWorkedOn.addTo(key, 1); // Folia - region threading
         if (references == 0) {
             final ChunkPos pos = new ChunkPos(chunkX, chunkZ);
             world.getChunkSource().addRegionTicket(ca.spottedleaf.starlight.common.light.StarLightInterface.CHUNK_WORK_TICKET, pos, 0, pos);
@@ -170,15 +172,15 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
 
         // Folia start - region threading
         updateFuture.onComplete.thenAccept((final Void ignore) -> {
-            io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+            RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
                 this.chunkMap.level, chunkX, chunkZ, () -> {
-                    final int newReferences = Level.WORLD_DATA_POOL.getDataAnyThread(this.chunkMap.level,chunkX << 4,chunkZ << 4).chunksBeingWorkedOn.get(key);
+                    final int newReferences = Level.WORLD_DATA_POOL.getDataAnyThread(chunkX,chunkZ,this.chunkMap.level).chunksBeingWorkedOn.get(key);
                     if (newReferences == 1) {
-                        Level.WORLD_DATA_POOL.getDataAnyThread(this.chunkMap.level,chunkX << 4,chunkZ << 4).chunksBeingWorkedOn.remove(key);
+                        Level.WORLD_DATA_POOL.getDataAnyThread(chunkX,chunkZ, this.chunkMap.level).chunksBeingWorkedOn.remove(key);
                         final ChunkPos pos = new ChunkPos(chunkX, chunkZ);
-                        world.getChunkSource().removeRegionTicket(ca.spottedleaf.starlight.common.light.StarLightInterface.CHUNK_WORK_TICKET, pos, 0, pos);
+                        world.getChunkSource().removeRegionTicket(StarLightInterface.CHUNK_WORK_TICKET, pos, 0, pos);
                     } else {
-                        Level.WORLD_DATA_POOL.getDataAnyThread(this.chunkMap.level,chunkX << 4,chunkZ << 4).chunksBeingWorkedOn.put(key, newReferences - 1);
+                        Level.WORLD_DATA_POOL.getDataAnyThread(chunkX,chunkZ, this.chunkMap.level).chunksBeingWorkedOn.put(key, newReferences - 1);
                     }
                 }
             );
